# Section 4. Variables

## 变量的定义

- rust中使用`let`关键字对变量进行赋值
- 变量默认是不可变的
- 如果在变量前面加上`mut`关键字，可以使变量成为一个可变的

```rust
let x = 5;  // 默认x是不可变的变量
x = 10;  // 这里编译会报错：cannot assign twice to immutable variable
```

```rust
let mut x = 5;  // 使用mut关键字使x成为可变的变量
x = 10;
println!("The value of x is {}", x);  // 这里会输出10
```

## 常量的定义

```rust
const MAX_POINTS: u32 = 100_100;
```

常量，顾名思义就是不可变的值。它与不可变的变量的区别如下：

- 不能使用`mut`关键字，常量永远都是不可变的
- 常量的声明使用`const`关键字，它的类型必须被标注
- 常量可以在任意作用于声明，包括全局作用域
- 常量只能绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值

程序运行期间，常量在其声明的作用域内一直有效

命名规范：全部为大写字母，通过`_`分隔单词

## shadowing特性

Rust中可以使用相同的名字声明新的变量，新的变量会shadow之前声明的同名变量

```rust
// 一个shadow的示例
let x = 5;
let x = x + 1;
println!("The value of x is {}", x);  // 输出x的值为6
// ---------------------------------------------------
// 一个类似shadow的示例
let x = 5;
x = 10;  // 这里会报错，因为x不可变
// ---------------------------------------------------
// 另一个类似shadow的示例
let mut x = 5;  // 这里将x定义为可变的
x = 10;  // 不会报错了
```

从上面例子中，可以发现`shadow`特性和增加了`mut`关键字的变量的效果好像比较类似，其实他们是有区别的：

- 如果不使用`let`关键字，那么重新给非`mut`变量赋值会导致编译报错
- 如果使用`let`声明的同名新变量，也是不可变的
- 使用`let`声明的同名新变量，它的类型可以与之前不同

## 数据类型

rust中数据类型分为标量类型和复合类型

rust是静态编译语言，在编译时必须知道所有变量的类型

- 基于使用的值，编译器通常能够推断出它的具体类型
- 但是如果可能的类型比较多的话（例如把`String`转为整数的`parse`方法），就必须添加类型的标注，否则编译会报错

```rust
// parse()返回的类型可能性多，编译器无法推断其类型
let guess: u32 = "42".parse().expect("not a number");
```

### 标量类型

一个标量类型代表一个单个的值

rust有四个主要的标量类型：

- 整数类型
- 浮点类型
- 布尔类型
- 字符类型

#### 整数类型

整数类型没有小数部分

无符号整数类型以`u`开头

有符号整数类型以`i`开头

下表为rust整数类型：

- 每种类型都分为`u`和`i`，以及固定的位数
- 有符号范围：[ -($2^n$ - 1) , $2^{n - 1}$ - 1 ]
- 无符号范围：[ 0 , $2^n$ - 1 ]

| Length   | Signed | Unsigned |
| -------- | ------ | -------- |
| 8-bit    | i8     | u8       |
| 16-bit   | i16    | u16      |
| 32-bit   | i32    | u32      |
| 64-bit   | i64    | u64      |
| 128-bit  | i128   | u128     |
| arch     | isize  | usize    |

`isize`和`usize`类型的位数由程序运行的计算机的架构决定，如果是64位的计算机，那么就是64位的，即`i64`和`u64`，如果是32位计算机，那么就等价于`i32`和`u32`;

使用`isize`或`usize`的场景并不多，主要场景是对某种集合进行索引操作。

##### 整数字面值

除了`byte`类型外，所有的数值字面值都允许使用类型后缀，例如：`57u8`

如果你不太清楚应该使用哪种类型，可以使用rust相应的默认类型：整数的默认类型是`i32`，无论是在64位系统还是32位系统，总体来看它的速度都是很快的。

| Number literals | Example     | Description |
| --------------- | ----------- | ----------- |
| Decimal         | 98_222      | 十进制，可以通过下划线增加可读性 |
| Hex             | 0xff        | 十六进制，使用`0x`开头，可以通过下划线增加可读性 | 
| Octal           | 0o77        | 八进制，使用`0o`开头，可以通过下划线增加可读性 |
| Binary          | 0b1111_0000 | 二进制，使用`0b`开头，可以通过下划线增加可读性 | 
| Byte (u8 only)  | b'A'        | |

##### 整数溢出

例如：`u8`的范围是`0 - 255`，如果把一个`u8`变量的值设为256，那么：

- 调试模式下编译：rust会检查整数溢出，如果发生溢出，程序在运行时就会panic
- 发布模式（`--release`）下编译：rust不会检查可能导致panic的整数溢出，一旦发生溢出，rust会执行**环绕**操作，即`256变成0, 257变成1, ...`，但程序不会panic

#### 浮点类型

rust有两种基础的浮点类型

- `f32`，32位，单精度
- `f64`，64位，双精度；默认类型，因为在现在CPU上`f64`和`f32`的速度差不多，而且经度更高

rust的浮点类型使用了**IEEE-754**标准来表述

```rust
let x = 3.0;  // f64
let y: f32 = 2.0;  // f32
```

#### 数值的操作

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
```

#### 布尔类型

- 两个值：`true` 和 `false`
- 一个字节大小
- 符号是`bool`

```rust
let x = false;  // 编译器自动推断为bool
let y: bool = true;  // 显式指定为bool
```

#### 字符类型

- `char`类型被用来描述语言中最基础的单个字符
- 字符类型的字面值使用单引号
- 占用4字节大小
- 是`Unicode`标量值，可以表示比`ASCII`多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等
    - `U+0000`到`U+D7FF`
    - `U+E000`到`U+10FFFF`
- 但`Unicode`中并没有“字符”的概念，所以直觉上认为的字符也许与rust中的概念并不相符

```rust
let c = 'z';
let z: char = 'ℤ'; // with explicit type annotation
let heart_eyed_cat = '😻';
```


### 复合类型







