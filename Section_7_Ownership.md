# Section 7. Ownership - 所有权

所有权是rust最独特的特性，它让rust无需GC就可以保证内存安全

## 什么是所有权

rust的核心特性就是所有权

所有程序在运行时，都必须管理它们使用计算机内存的方式

- 有些语言有垃圾收集机制，在程序运行时，它们会不断寻找不再使用的内存（例如java）
- 在其它语言中，程序员必须显示地分配和释放内存（例如c）

rust采用了第三种方式：

- 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
- 当程序运行时，所有权特性不会减慢程序的运行速度

## Stack vs Heap

在像rust这样的系统级编程语言里，一个值是在stack上还是heap上对语言的行为和你为什么要做某些决定是有更大的影响的。

在你的代码运行时，stack和heap都是你的可用内存，但是它们的结构很不相同。

- **Stack**: 栈内存，按值的接收顺序进行存储，按相反的顺序将它们移除，即后进先出`LIFO`
    - 添加数据叫做压入栈，移除数据叫做弹出栈
    - stack的压入栈不叫分配
    - 所有存储在Stack上的数据必须拥有已知的固定大小
    - 因为指针是已知固定大小的，可以把指针存放在stack上，但是如果想要实际的数据，你必须使用指针来进行定位
    - 把数据压倒stack上要比在heap上快得多，因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在stack的顶端
- **Heap**: 堆内存，内存组织性差一些
    - 当你把数据放入heap时，会请求一定数量的空间
    - 操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址
    - 这个过程叫做在heap上进行分配，有时仅仅称为“分配”
    - 在heap上分配空间需要做更多的工作，操作系统首先需要寻找到一个足够大的空间来存放数据，然后要做好记录方便下次分配

### 数据访问

- 访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据，对于现代处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快
- 如果数据存放的距离比较远，那么处理器的处理速度就会更快一些（stack上）
- 如果数据存放的距离比较近，那么处理器的处理速度就会慢一些（heap上）
    - 在heap上分配大量的空间也是需要时间的

### 函数调用
当你的代码在调用函数时，值被传入到函数（也包括指向heap的指针）。函数本地的变量被压倒stack上。当函数执行结束后，这些值会从stack上弹出

### 所有权存在的原因

所有权解决的问题：

- 跟踪代码的哪些部分正在使用heap的哪些数据
- 最小化heap上的重复数据
- 清理heap上未使用的数据以避免空间不足

一旦你懂了所有权，那么就不需要经常去想stack或heap了，但是知道管理heap数据是所有权存在的原因，有助于解释它为什么会这样工作。

## 所有权规则

1. 每个值都有一个变量，这个变量就是该值的所有者
2. 每个值同时只能有一个所有者
3. 当所有者超出作用域（scope）时，该值将被删除
    - 作用域是程序中一个项目的有效范围

```rust
fn main() {
    // s不可用
    let s = "hello";  // s可用
                      // 可以对s进行相关操作
}   // s作用域到此结束，s不再可用
```

### 根据String了解所有权

选择`String`类型的原因是，`String`比基础标量数据类型更复杂。

之前，我们使用的是字符串字面值的方式定义的字符串类型，它们是不可变的

rust中还有第二种字符串类型：`String`，它在heap上分配空间，能够存储在编译时未知数量的文本

#### 如何创建String类型的值

通过`from`函数从字符串字面值创建出`String`类型，语法如下：

- `let s = String::from("hello");`
    - `::`表示`from`是`String`类型下的函数

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", World");
    println!("{}", s);
}
```

通过上面的例子，我们可以发现`String`类型的值是可以修改的，但是之前使用过的字符串字面值却不能修改，这是因为它们处理内存的方式不同。

#### 内存和分配

- **字符串字面值**: 在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里
    - 速度快、高效是因为其不可变性
- **String类型**: 为了支持其可变性，需要在heap上分配内存来保存编译时未知的文本内容
    - 操作系统必须在运行时来请求内存，这一步通过调用`String::from`来实现
    - 当用完`String`后，需要使用某种方式将内存返还给操作系统
        - 有GC的语言中，GC会负责跟踪并清理不再使用的内存
        - 没有GC的语言中，需要我们去识别内存何时不再使用，并调用代码将其返回
            - 如果忘了，会浪费内存，即内存泄漏
            - 如果提前做了，会导致变量非法
            - 如果做了两次，也就是BUG，必须一次分配对应一次释放
        - **rust采用了不同的方式，对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的返还给操作系统**
            - 当一个变量离开作用域时，rust会调用`drop`函数

### 变量和数据交互的方式：移动（Move）

多个变量可以与同一数据使用一种独特的方式来交互：

```rust
// 整数是已知且固定大小的简单值，这两个5被压到了stack中
let x = 5; 
let y = x;

// 接下来是string的版本
let s1 = String::from("hello");
let s2 = s1;
```

### 具体分析

#### String的基本内存结构

<img src="images/trpl04-01.svg" width=30% height=30% style="float: right;">

- 一个`String`由3部分组成：
    - 一个指向存放字符串内容的内存的指针
    - 一个长度
    - 一个容量
- 上面这些东西都存放在stack上
- 存放字符串内容的部分在heap上
- 长度`len`，就是存放字符串内容所需的字节数

